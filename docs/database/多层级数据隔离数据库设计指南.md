# 多层级数据隔离数据库设计指南

## 📋 目录

1. [概述](#概述)
2. [核心隔离字段设计](#核心隔离字段设计)
3. [表结构设计要求](#表结构设计要求)
4. [索引设计策略](#索引设计策略)
5. [约束设计规则](#约束设计规则)
6. [实际表设计示例](#实际表设计示例)
7. [性能优化建议](#性能优化建议)
8. [安全策略设计](#安全策略设计)
9. [数据迁移策略](#数据迁移策略)

---

## 概述

多层级数据隔离的数据库设计需要确保不同租户、组织、部门的数据完全分离，同时支持灵活的查询和高效的数据访问。本指南将详细说明如何在数据库层面实现这些要求。

### 设计原则

- **数据完整性**：确保隔离字段的数据一致性
- **查询性能**：通过合理的索引设计优化查询速度
- **安全隔离**：防止跨层级的数据泄露
- **扩展性**：支持未来的层级扩展需求

---

## 核心隔离字段设计

### 必需字段

每个业务表都必须包含以下隔离字段：

```sql
-- 多层级隔离字段
tenant_id UUID NOT NULL,           -- 租户ID（必填）
organization_id UUID,              -- 组织ID（可选）
department_id UUID,                -- 部门ID（可选）
user_id UUID,                      -- 用户ID（可选，用于用户级隔离）
```

### 字段说明

| 字段名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `tenant_id` | UUID | ✅ | 租户级隔离的核心字段，所有业务数据都必须有 |
| `organization_id` | UUID | ❌ | 组织级隔离字段，当数据属于特定组织时使用 |
| `department_id` | UUID | ❌ | 部门级隔离字段，当数据属于特定部门时使用 |
| `user_id` | UUID | ❌ | 用户级隔离字段，当数据属于特定用户时使用 |

### 数据类型选择

- **UUID类型**：推荐使用UUID作为隔离字段类型
  - 优点：全局唯一、安全性高、支持分布式系统
  - 缺点：存储空间较大（16字节）
  - 替代方案：可以使用ULID或自定义ID格式

---

## 表结构设计要求

### 1. 标准表结构模板

```sql
-- 业务表标准模板
CREATE TABLE {table_name} (
  -- 主键
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 多层级隔离字段（必需）
  tenant_id UUID NOT NULL,
  organization_id UUID,
  department_id UUID,
  user_id UUID,
  
  -- 业务字段
  {business_columns},
  
  -- 审计字段
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1 NOT NULL,
  
  -- 创建者信息（可选）
  created_by UUID,
  updated_by UUID,
  
  -- 约束
  CONSTRAINT chk_{table_name}_tenant_not_null CHECK (tenant_id IS NOT NULL),
  CONSTRAINT chk_{table_name}_org_with_tenant CHECK (
    organization_id IS NULL OR tenant_id IS NOT NULL
  ),
  CONSTRAINT chk_{table_name}_dept_with_org CHECK (
    department_id IS NULL OR (
      tenant_id IS NOT NULL AND organization_id IS NOT NULL
    )
  )
);
```

### 2. 层级依赖关系约束

```sql
-- 确保层级依赖关系的完整性
-- 组织级数据必须有租户
ALTER TABLE {table_name} ADD CONSTRAINT chk_org_with_tenant 
CHECK (organization_id IS NULL OR tenant_id IS NOT NULL);

-- 部门级数据必须有租户和组织
ALTER TABLE {table_name} ADD CONSTRAINT chk_dept_with_org 
CHECK (
  department_id IS NULL OR (
    tenant_id IS NOT NULL AND organization_id IS NOT NULL
  )
);

-- 用户级数据可选租户
ALTER TABLE {table_name} ADD CONSTRAINT chk_user_optional_tenant 
CHECK (user_id IS NULL OR tenant_id IS NULL OR tenant_id IS NOT NULL);
```

---

## 索引设计策略

### 1. 基础索引

```sql
-- 租户级索引（最重要，查询频率最高）
CREATE INDEX idx_{table_name}_tenant_id ON {table_name}(tenant_id);

-- 组织级索引（部分索引，只为非空值创建）
CREATE INDEX idx_{table_name}_organization_id 
ON {table_name}(organization_id) 
WHERE organization_id IS NOT NULL;

-- 部门级索引（部分索引，只为非空值创建）
CREATE INDEX idx_{table_name}_department_id 
ON {table_name}(department_id) 
WHERE department_id IS NOT NULL;

-- 用户级索引（部分索引，只为非空值创建）
CREATE INDEX idx_{table_name}_user_id 
ON {table_name}(user_id) 
WHERE user_id IS NOT NULL;
```

### 2. 复合索引

```sql
-- 层级复合索引（按查询频率排序）
CREATE INDEX idx_{table_name}_tenant_org 
ON {table_name}(tenant_id, organization_id) 
WHERE organization_id IS NOT NULL;

CREATE INDEX idx_{table_name}_tenant_org_dept 
ON {table_name}(tenant_id, organization_id, department_id) 
WHERE organization_id IS NOT NULL AND department_id IS NOT NULL;

CREATE INDEX idx_{table_name}_tenant_org_dept_user 
ON {table_name}(tenant_id, organization_id, department_id, user_id) 
WHERE organization_id IS NOT NULL AND department_id IS NOT NULL AND user_id IS NOT NULL;

-- 软删除索引
CREATE INDEX idx_{table_name}_active 
ON {table_name}(tenant_id) 
WHERE deleted_at IS NULL;

-- 更新时间索引（用于增量同步）
CREATE INDEX idx_{table_name}_updated_at 
ON {table_name}(updated_at) 
WHERE deleted_at IS NULL;
```

### 3. 查询优化索引

```sql
-- 常用查询组合索引
CREATE INDEX idx_{table_name}_tenant_status 
ON {table_name}(tenant_id, is_active) 
WHERE deleted_at IS NULL;

CREATE INDEX idx_{table_name}_tenant_created_at 
ON {table_name}(tenant_id, created_at) 
WHERE deleted_at IS NULL;

-- 全文搜索索引（如果需要）
CREATE INDEX idx_{table_name}_search 
ON {table_name} USING gin(to_tsvector('english', search_content));
```

---

## 约束设计规则

### 1. 唯一性约束

```sql
-- 租户内唯一约束
ALTER TABLE {table_name} ADD CONSTRAINT uq_{table_name}_tenant_code 
UNIQUE (tenant_id, code);

-- 组织内唯一约束
ALTER TABLE {table_name} ADD CONSTRAINT uq_{table_name}_org_code 
UNIQUE (tenant_id, organization_id, code) 
WHERE organization_id IS NOT NULL;

-- 部门内唯一约束
ALTER TABLE {table_name} ADD CONSTRAINT uq_{table_name}_dept_code 
UNIQUE (tenant_id, organization_id, department_id, code) 
WHERE organization_id IS NOT NULL AND department_id IS NOT NULL;
```

### 2. 外键约束

```sql
-- 租户外键约束
ALTER TABLE {table_name} ADD CONSTRAINT fk_{table_name}_tenant 
FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE;

-- 组织外键约束
ALTER TABLE {table_name} ADD CONSTRAINT fk_{table_name}_organization 
FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE;

-- 部门外键约束
ALTER TABLE {table_name} ADD CONSTRAINT fk_{table_name}_department 
FOREIGN KEY (department_id) REFERENCES departments(id) ON DELETE CASCADE;

-- 用户外键约束
ALTER TABLE {table_name} ADD CONSTRAINT fk_{table_name}_user 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL;
```

### 3. 检查约束

```sql
-- 版本号约束
ALTER TABLE {table_name} ADD CONSTRAINT chk_{table_name}_version_positive 
CHECK (version > 0);

-- 时间约束
ALTER TABLE {table_name} ADD CONSTRAINT chk_{table_name}_created_before_updated 
CHECK (created_at <= updated_at);

-- 软删除约束
ALTER TABLE {table_name} ADD CONSTRAINT chk_{table_name}_deleted_at_with_updated 
CHECK (deleted_at IS NULL OR deleted_at >= updated_at);
```

---

## 实际表设计示例

### 1. 用户表（Users）

```sql
CREATE TABLE users (
  -- 主键
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 多层级隔离字段
  tenant_id UUID NOT NULL,
  organization_id UUID,
  department_id UUID,
  
  -- 用户基本信息
  username VARCHAR(100) NOT NULL,
  email VARCHAR(255) NOT NULL,
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  phone VARCHAR(20),
  
  -- 状态字段
  is_active BOOLEAN DEFAULT TRUE NOT NULL,
  email_verified BOOLEAN DEFAULT FALSE NOT NULL,
  
  -- 审计字段
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1 NOT NULL,
  
  -- 约束
  CONSTRAINT uq_users_tenant_email UNIQUE (tenant_id, email),
  CONSTRAINT uq_users_tenant_username UNIQUE (tenant_id, username),
  CONSTRAINT chk_users_org_with_tenant CHECK (
    organization_id IS NULL OR tenant_id IS NOT NULL
  ),
  CONSTRAINT chk_users_dept_with_org CHECK (
    department_id IS NULL OR (
      tenant_id IS NOT NULL AND organization_id IS NOT NULL
    )
  ),
  CONSTRAINT chk_users_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z{},9.-]+\.[A-Za-z]{2,}$')
);

-- 索引
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE organization_id IS NOT NULL;
CREATE INDEX idx_users_department_id ON users(department_id) WHERE department_id IS NOT NULL;
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_active ON users(tenant_id) WHERE deleted_at IS NULL AND is_active = TRUE;
CREATE INDEX idx_users_tenant_org ON users(tenant_id, organization_id) WHERE organization_id IS NOT NULL;
```

### 2. 产品表（Products）

```sql
CREATE TABLE products (
  -- 主键
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 多层级隔离字段
  tenant_id UUID NOT NULL,
  organization_id UUID,
  department_id UUID,
  
  -- 产品信息
  name VARCHAR(200) NOT NULL,
  code VARCHAR(50) NOT NULL,
  description TEXT,
  price DECIMAL(10,2),
  currency VARCHAR(3) DEFAULT 'CNY',
  
  -- 状态字段
  status VARCHAR(20) DEFAULT 'draft' NOT NULL,
  is_active BOOLEAN DEFAULT TRUE NOT NULL,
  
  -- 审计字段
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1 NOT NULL,
  
  -- 约束
  CONSTRAINT uq_products_tenant_code UNIQUE (tenant_id, code),
  CONSTRAINT chk_products_price_positive CHECK (price IS NULL OR price >= 0),
  CONSTRAINT chk_products_status_valid CHECK (status IN ('draft', 'active', 'inactive', 'archived'))
);

-- 索引
CREATE INDEX idx_products_tenant_id ON products(tenant_id);
CREATE INDEX idx_products_organization_id ON products(organization_id) WHERE organization_id IS NOT NULL;
CREATE INDEX idx_products_department_id ON products(department_id) WHERE department_id IS NOT NULL;
CREATE INDEX idx_products_code ON products(code);
CREATE INDEX idx_products_active ON products(tenant_id) WHERE deleted_at IS NULL AND is_active = TRUE;
CREATE INDEX idx_products_status ON products(tenant_id, status) WHERE deleted_at IS NULL;
```

### 3. 订单表（Orders）

```sql
CREATE TABLE orders (
  -- 主键
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 多层级隔离字段
  tenant_id UUID NOT NULL,
  organization_id UUID,
  department_id UUID,
  user_id UUID, -- 订单属于特定用户
  
  -- 订单信息
  order_number VARCHAR(50) NOT NULL,
  customer_id UUID,
  total_amount DECIMAL(12,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'CNY',
  
  -- 状态字段
  status VARCHAR(20) DEFAULT 'pending' NOT NULL,
  payment_status VARCHAR(20) DEFAULT 'unpaid' NOT NULL,
  
  -- 审计字段
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1 NOT NULL,
  
  -- 约束
  CONSTRAINT uq_orders_tenant_number UNIQUE (tenant_id, order_number),
  CONSTRAINT chk_orders_amount_positive CHECK (total_amount >= 0),
  CONSTRAINT chk_orders_status_valid CHECK (status IN ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled'))
);

-- 索引
CREATE INDEX idx_orders_tenant_id ON orders(tenant_id);
CREATE INDEX idx_orders_organization_id ON orders(organization_id) WHERE organization_id IS NOT NULL;
CREATE INDEX idx_orders_department_id ON orders(department_id) WHERE department_id IS NOT NULL;
CREATE INDEX idx_orders_user_id ON orders(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_orders_customer_id ON orders(customer_id) WHERE customer_id IS NOT NULL;
CREATE INDEX idx_orders_status ON orders(tenant_id, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_orders_created_at ON orders(tenant_id, created_at) WHERE deleted_at IS NULL;
```

---

## 性能优化建议

### 1. 分区策略

```sql
-- 按租户ID分区（适用于大型系统）
CREATE TABLE users (
  -- 表结构...
) PARTITION BY HASH (tenant_id);

-- 创建分区
CREATE TABLE users_p0 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE users_p1 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE users_p2 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE users_p3 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

### 2. 查询优化

```sql
-- 使用覆盖索引避免回表
CREATE INDEX idx_users_tenant_covering 
ON users(tenant_id, organization_id, department_id) 
INCLUDE (id, username, email, is_active) 
WHERE deleted_at IS NULL;

-- 使用表达式索引
CREATE INDEX idx_users_email_lower 
ON users(lower(email));

-- 使用部分索引减少索引大小
CREATE INDEX idx_users_active_tenant 
ON users(tenant_id) 
WHERE is_active = TRUE AND deleted_at IS NULL;
```

### 3. 统计信息更新

```sql
-- 定期更新统计信息以优化查询计划
ANALYZE users;
ANALYZE products;
ANALYZE orders;

-- 设置自动统计信息更新
ALTER TABLE users SET (autovacuum_analyze_scale_factor = 0.01);
```

---

## 安全策略设计

### 1. 行级安全策略（RLS）

```sql
-- 启用行级安全
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- 创建安全策略函数
CREATE OR REPLACE FUNCTION get_current_tenant_id()
RETURNS UUID AS $$
BEGIN
  RETURN current_setting('app.current_tenant_id', true)::UUID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 创建租户级安全策略
CREATE POLICY tenant_isolation_policy ON users
  FOR ALL TO application_role
  USING (tenant_id = get_current_tenant_id());

-- 创建组织级安全策略
CREATE POLICY organization_isolation_policy ON users
  FOR ALL TO application_role
  USING (
    tenant_id = get_current_tenant_id() AND
    (
      organization_id IS NULL OR 
      organization_id = current_setting('app.current_organization_id', true)::UUID
    )
  );
```

### 2. 数据加密

```sql
-- 敏感字段加密（使用pgcrypto扩展）
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 加密存储敏感信息
ALTER TABLE users ADD COLUMN encrypted_phone BYTEA;
ALTER TABLE users ADD COLUMN encrypted_id_number BYTEA;

-- 创建加密函数
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(data TEXT, key TEXT)
RETURNS BYTEA AS $$
BEGIN
  RETURN pgp_sym_encrypt(data, key);
END;
$$ LANGUAGE plpgsql;

-- 创建解密函数
CREATE OR REPLACE FUNCTION decrypt_sensitive_data(encrypted_data BYTEA, key TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN pgp_sym_decrypt(encrypted_data, key);
END;
$$ LANGUAGE plpgsql;
```

---

## 数据迁移策略

### 1. 历史数据迁移

```sql
-- 迁移脚本模板
DO $$
DECLARE
  batch_size INTEGER := 1000;
  offset_val INTEGER := 0;
  total_count INTEGER;
BEGIN
  -- 获取总记录数
  SELECT COUNT(*) INTO total_count FROM old_table;
  
  -- 批量迁移
  WHILE offset_val < total_count LOOP
    INSERT INTO new_table (
      id, tenant_id, organization_id, department_id,
      -- 其他字段...
    )
    SELECT 
      id,
      COALESCE(tenant_id, 'default-tenant-id'),
      organization_id,
      department_id,
      -- 其他字段...
    FROM old_table
    ORDER BY id
    LIMIT batch_size OFFSET offset_val;
    
    offset_val := offset_val + batch_size;
    
    -- 提交事务
    COMMIT;
  END LOOP;
END $$;
```

### 2. 数据验证

```sql
-- 验证迁移完整性
WITH migration_check AS (
  SELECT 
    COUNT(*) as old_count,
    (SELECT COUNT(*) FROM new_table) as new_count
  FROM old_table
)
SELECT 
  CASE 
    WHEN old_count = new_count THEN 'SUCCESS'
    ELSE 'FAILED'
  END as migration_status,
  old_count,
  new_count
FROM migration_check;

-- 验证隔离字段完整性
SELECT 
  'tenant_id_null' as check_type,
  COUNT(*) as count
FROM new_table 
WHERE tenant_id IS NULL

UNION ALL

SELECT 
  'org_without_tenant' as check_type,
  COUNT(*) as count
FROM new_table 
WHERE organization_id IS NOT NULL AND tenant_id IS NULL;
```

---

## 最佳实践总结

### 1. 表设计原则

- ✅ **必须包含隔离字段**：每个业务表都要有完整的隔离字段
- ✅ **合理的索引设计**：为隔离字段创建适当的索引
- ✅ **约束完整性**：确保层级依赖关系的完整性
- ✅ **性能优化**：使用分区、覆盖索引等优化技术

### 2. 查询优化原则

- ✅ **隔离字段优先**：WHERE条件中优先使用隔离字段
- ✅ **避免全表扫描**：确保查询能够使用索引
- ✅ **合理使用缓存**：缓存键要包含隔离信息
- ✅ **监控查询性能**：定期分析慢查询

### 3. 安全原则

- ✅ **最小权限原则**：用户只能访问必要的数据
- ✅ **数据加密**：敏感数据要加密存储
- ✅ **审计日志**：记录所有数据访问操作
- ✅ **滚级安全策略**：使用数据库级别的安全策略

### 4. 维护原则

- ✅ **定期维护**：更新统计信息、重建索引
- ✅ **监控告警**：监控数据库性能和错误
- ✅ **备份策略**：制定完整的数据备份和恢复策略
- ✅ **版本管理**：使用数据库迁移管理表结构变更

---

## 附录

### 相关工具

- **数据库管理**：pgAdmin、DBeaver、DataGrip
- **性能监控**：pg_stat_statements、pg_stat_activity
- **备份恢复**：pg_dump、pg_restore、WAL-E

### 相关文档

- [PostgreSQL官方文档](https://www.postgresql.org/docs/)
- [数据库性能调优指南](./database-performance-tuning.md)
- [数据迁移最佳实践](./data-migration-best-practices.md)

---

*最后更新：2024年1月*
